<!-- Thematic Radar Chart Component v1.1 - With Word Lists -->
<!-- Multi-song overlay with similarity-based comparison -->

<div class="analysis-section" id="thematicRadar" data-order="15" data-focus="thematic-radar">

    <!-- VERTICAL HEADER (Uniform Style) -->
    <div class="vertical-header" onclick="toggleSection('thematicRadar')">
        <h3 class="section-title">Thematic Radar</h3>
        <div class="vertical-controls">
            <button class="vertical-move-arrow" onclick="moveSection('thematicRadar', 'up'); event.stopPropagation();">‚ñ≤</button>
            <button class="vertical-move-arrow" onclick="moveSection('thematicRadar', 'down'); event.stopPropagation();">‚ñº</button>
        </div>
    </div>

    <div class="section-content">

        <!-- Info Panel -->
        <div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #3498db;">
            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                <h4 style="margin: 0; color: #2c3e50; font-size: 16px;"><span id="axisCountLabel">6</span> Thematic Axes Analysis</h4>
                <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; font-size: 13px; color: #666;">
                    <input type="checkbox" id="includeFunctionalWords" onchange="toggleFunctionalWords()" style="cursor: pointer;">
                    <span>Include functional words (grammar, particles)</span>
                </label>
            </div>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; font-size: 13px; color: #666;">
                <div><strong>üåø Nature:</strong> trƒÉng, s√¥ng, chi·ªÅu, hoa, c√≤, m√¢y, n√∫i, c√¢y</div>
                <div><strong>üë®‚Äçüë©‚Äçüëß Family:</strong> ch·ªìng, v·ª£, m·∫π, cha, con, anh, em, b√†, √¥ng</div>
                <div><strong>üíó Emotion:</strong> th∆∞∆°ng, nh·ªõ, bu·ªìn, vui, kh·ªï, ƒëau, y√™u, s·∫ßu</div>
                <div><strong>‚öíÔ∏è Work:</strong> l√†m, gi√£, ƒë·∫≠p, ch√®o, k√©o, c√†y, tr·ªìng, d·ªát</div>
                <div><strong>‚è∞ Time:</strong> chi·ªÅu, s√°ng, ƒë√™m, ng√†y, m√πa, l√∫c, th·ªùi</div>
                <div><strong>üìç Place:</strong> l√†ng, s√¥ng, nh√†, ƒë√≤, ch√πa, c·∫ßu, n√∫i, ƒë·ªìng</div>
                <div id="otherCategoryInfo" style="display: none;"><strong>üí¨ Other:</strong> ∆°i, √†, m√†, cho, v√† (functional)</div>
            </div>
        </div>

        <!-- Controls Row 1: Comparison Mode -->
        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
            <label style="font-weight: 600; color: #555; display: block; margin-bottom: 8px;">Comparison Mode:</label>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button onclick="setRadarMode('current-vs-avg')" class="radar-mode-btn active" data-mode="current-vs-avg" style="padding: 8px 16px; border: 2px solid #3498db; background: #e3f2fd; color: #3498db; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 13px;">Current vs. Average</button>
                <button onclick="setRadarMode('multi-song')" class="radar-mode-btn" data-mode="multi-song" style="padding: 8px 16px; border: 1px solid #ddd; background: white; color: #666; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 13px;">Multi-Song Overlay</button>
                <button onclick="setRadarMode('regional')" class="radar-mode-btn" data-mode="regional" style="padding: 8px 16px; border: 1px solid #ddd; background: white; color: #666; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 13px;">Regional Comparison</button>
                <button onclick="setRadarMode('genre')" class="radar-mode-btn" data-mode="genre" style="padding: 8px 16px; border: 1px solid #ddd; background: white; color: #666; border-radius: 5px; cursor: pointer; font-weight: 600; font-size: 13px;">Genre Comparison</button>
            </div>
        </div>

        <!-- Controls Row 2: Multi-Song Selection (only visible in multi-song mode) -->
        <div id="multiSongControls" style="background: #fff3e0; padding: 15px; border-radius: 8px; margin-bottom: 20px; display: none;">
            <div style="display: flex; gap: 15px; align-items: start; flex-wrap: wrap;">
                <div style="flex: 1; min-width: 300px;">
                    <label style="font-weight: 600; color: #555; display: block; margin-bottom: 8px;">Select Songs to Compare:</label>
                    <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                        <select id="songSelector" style="flex: 1; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 13px;">
                            <option value="">-- Choose a song --</option>
                        </select>
                        <button onclick="addSongToRadar()" style="padding: 8px 16px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Add</button>
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <button onclick="addSimilarSongs()" style="padding: 6px 12px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">+ Top 5 Similar</button>
                        <button onclick="addDifferentSongs()" style="padding: 6px 12px; background: #e74c3c; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">+ Top 5 Different</button>
                        <button onclick="clearAllSongs()" style="padding: 6px 12px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Clear All</button>
                    </div>
                </div>
                <div id="selectedSongsList" style="flex: 1; min-width: 300px;">
                    <div style="font-weight: 600; color: #555; margin-bottom: 8px;">Selected Songs (max 10):</div>
                    <div id="selectedSongsChips" style="display: flex; flex-wrap: wrap; gap: 6px; min-height: 40px;">
                        <div style="color: #999; font-size: 12px;">No songs selected</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Main Chart Area -->
        <div style="display: flex; gap: 20px; align-items: start; flex-wrap: wrap;">
            <!-- Radar Chart -->
            <div style="flex: 1; min-width: 500px; max-width: 700px;">
                <canvas id="thematicRadarChart" width="600" height="600"></canvas>
            </div>

            <!-- Legend & Insights -->
            <div id="radarInsights" style="flex: 1; min-width: 400px; background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 600px; overflow-y: auto;">
                <h4 style="margin: 0 0 15px 0; color: #2c3e50;">Insights</h4>
                <div id="insightsContent" style="color: #666; font-size: 13px; line-height: 1.6;">
                    Loading...
                </div>
            </div>
        </div>

    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.js"></script>

<script>
// Thematic Radar Chart with Multi-Song Overlay
(function() {
    let thematicProfiles = null;
    let vocabularyMetrics = null;
    let radarChart = null;
    let currentMode = 'current-vs-avg';
    let selectedSongs = []; // For multi-song mode
    let currentSong = null;
    let includeFunctionalWords = false; // Toggle for 6-axis vs 7-axis

    const categoryColors = {
        nature: '#27ae60',
        family: '#e74c3c',
        emotion: '#f39c12',
        work: '#3498db',
        time: '#9b59b6',
        place: '#1abc9c',
        other: '#95a5a6'
    };

    // Semantic patterns (same as generate-thematic-profiles.js)
    const semanticPatterns = {
        nature: /trƒÉng|s√¥ng|chi·ªÅu|hoa|c√≤|ƒë√≤|m√¢y|n√∫i|bi·ªÉn|c√¢y|l√°|r·ª´ng|ƒë·ªìng|r·∫´y|m∆∞a|gi√≥|sao|tr·ªùi|s∆∞∆°ng|m√π|n·∫Øng|b√£o|l≈©|h·∫°n|n∆∞·ªõc|ao|h·ªì|su·ªëi|gi·∫øng|non|c√†nh|l√∫a|ng√¥|c·∫£nh/i,
        family: /ch·ªìng|v·ª£|m·∫π|cha|con|anh|em|b√†|√¥ng|c√¥|ch√∫|b√°c|ch√°u|b·ªë|me|ch·ªã|trai|g√°i|n√†ng|phu|th√™|nhi|t·ª≠|ph·ª•|m·∫´u|ng∆∞·ªùi|b·∫°n/i,
        emotion: /th∆∞∆°ng|nh·ªõ|bu·ªìn|vui|kh·ªï|ƒëau|y√™u|gh√©t|s·ª£|s·∫ßu|h·∫≠n|oan|t√¨nh|c·∫£m|vui|h·∫°nh|ph√∫c|gi·∫≠n|·ª©c|√≥a/i,
        work: /l√†m|gi√£|ƒë·∫≠p|ch√®o|k√©o|c√†y|b·ª´a|tr·ªìng|thu|d·ªát|may|n·∫•u|h√≤|gi√£|m√†i|h√°i|sƒÉn|ƒë√°nh|b·∫Øn|ƒëan|ch·∫ª|x·∫ª|ƒëi/i,
        time: /chi·ªÅu|s√°ng|tr∆∞a|t·ªëi|ƒë√™m|h√¥m|mai|ng√†y|th√°ng|nƒÉm|m√πa|l√∫c|khi|th·ªùi|r·ªìi|nay|x∆∞a|s·ªõm|tr∆∞·ªõc|sau/i,
        place: /l√†ng|th√†nh|ph·ªë|ch·ª£|nh√†|l·∫ßu|c·∫ßu|ƒë√≤|thuy·ªÅn|b·∫øn|s√¥ng|n√∫i|n∆°i|ch·ªën|x·ª©|qu√™|h∆∞∆°ng|ƒë·∫•t|tr·ªùi|hang|h·ªë|b·ªù|c·ª≠a|ph·ªß|ƒë√¨nh|ch√πa|mi·∫øu|qu√°n|v∆∞·ªùn|s√¢n|ƒë∆∞·ªùng|l·ªëi|xa/i
    };

    // Context rules (same as generate-thematic-profiles.js)
    const contextRules = [
        { word: 'con', nextPattern: /^(kh·ªâ|c√≤|voi|b√≤|g√†|ch√≥|m√®o|c√°|chim|√©n|s·∫ª|qu·∫°|di·ªÅu|h√¢u)$/i, category: 'nature' },
        { word: /^(kh·ªâ|voi|b√≤|g√†|ch√≥|m√®o|c√°|chim|√©n|s·∫ª|qu·∫°|di·ªÅu|h√¢u)$/i, prevWord: 'con', category: 'nature' },
        { word: 'nh√†', nextPattern: /^(t√¥i|ta|m√¨nh|n√≥|ng∆∞·ªùi)$/i, category: 'family' },
        { word: 'ƒë·ªùi', nextPattern: /^(t√¥i|ta|m√¨nh|ng∆∞·ªùi)$/i, category: 'emotion' }
    ];

    function categorizeWord(word, index, allWords) {
        const wordLower = word.toLowerCase();
        const nextWord = allWords[index + 1] ? allWords[index + 1].toLowerCase() : '';
        const prevWord = allWords[index - 1] ? allWords[index - 1].toLowerCase() : '';

        // Check context rules first
        for (const rule of contextRules) {
            if (rule.nextPattern && rule.word) {
                const wordMatch = typeof rule.word === 'string'
                    ? wordLower === rule.word
                    : rule.word.test(wordLower);

                if (wordMatch && rule.nextPattern.test(nextWord)) {
                    return rule.category;
                }
            }

            if (rule.prevWord && rule.word) {
                const wordMatch = typeof rule.word === 'string'
                    ? wordLower === rule.word
                    : rule.word.test(wordLower);

                if (wordMatch && prevWord === rule.prevWord) {
                    return rule.category;
                }
            }
        }

        // Default pattern matching
        for (const [category, pattern] of Object.entries(semanticPatterns)) {
            if (pattern.test(wordLower)) {
                return category;
            }
        }

        return 'other';
    }

    function categorizeAllWords(lyricsData) {
        const wordsByCategory = {
            nature: [],
            family: [],
            emotion: [],
            work: [],
            time: [],
            place: [],
            other: []
        };

        lyricsData.phrases.forEach(phrase => {
            if (phrase.wordMapping) {
                const allWords = phrase.wordMapping.map(m => m.vn);

                phrase.wordMapping.forEach((mapping, index) => {
                    const word = mapping.vn;
                    const category = categorizeWord(word, index, allWords);
                    wordsByCategory[category].push(word);
                });
            }
        });

        return wordsByCategory;
    }

    const chartColors = [
        { bg: 'rgba(52, 152, 219, 0.2)', border: '#3498db' },   // Blue
        { bg: 'rgba(231, 76, 60, 0.2)', border: '#e74c3c' },    // Red
        { bg: 'rgba(39, 174, 96, 0.2)', border: '#27ae60' },    // Green
        { bg: 'rgba(243, 156, 18, 0.2)', border: '#f39c12' },   // Orange
        { bg: 'rgba(155, 89, 182, 0.2)', border: '#9b59b6' },   // Purple
        { bg: 'rgba(26, 188, 156, 0.2)', border: '#1abc9c' },   // Teal
        { bg: 'rgba(241, 196, 15, 0.2)', border: '#f1c40f' },   // Yellow
        { bg: 'rgba(230, 126, 34, 0.2)', border: '#e67e22' },   // Carrot
        { bg: 'rgba(52, 73, 94, 0.2)', border: '#34495e' },     // Dark
        { bg: 'rgba(149, 165, 166, 0.2)', border: '#95a5a6' }   // Gray
    ];

    async function loadData() {
        try {
            const [profilesRes, metricsRes] = await Promise.all([
                fetch('/api/thematic-profiles'),
                fetch('/api/vocabulary-metrics')
            ]);

            thematicProfiles = await profilesRes.json();
            vocabularyMetrics = await metricsRes.json();

            // Get current song from URL parameter
            const urlParams = new URLSearchParams(window.location.search);
            let currentSongName = (urlParams.get('song') || 'B√† r·∫±ng b√† r√≠').replace(/\.musicxml\.xml$/i, '');

            // Normalize URL parameter to handle combining diacritics
            currentSongName = currentSongName.normalize('NFC');

            console.log('[ThematicRadar] Raw URL parameter:', urlParams.get('song'));
            console.log('[ThematicRadar] Normalized song name:', currentSongName);
            console.log('[ThematicRadar] Available profiles:', thematicProfiles.profiles.slice(0, 5).map(p => p.songName));

            // Try multiple matching strategies (ordered by precision)
            currentSong = thematicProfiles.profiles.find(p => {
                const pNameNorm = p.songName.normalize('NFC').toLowerCase();
                const pTitleNorm = (p.songTitle || '').normalize('NFC').toLowerCase();
                const currentNorm = currentSongName.normalize('NFC').toLowerCase();

                // Strategy 1: Exact songTitle match (highest priority)
                if (pTitleNorm === currentNorm) {
                    console.log('[ThematicRadar] Match strategy 1 (exact songTitle):', p.songName);
                    return true;
                }
                // Strategy 2: Exact songName match
                if (pNameNorm === currentNorm) {
                    console.log('[ThematicRadar] Match strategy 2 (exact songName):', p.songName);
                    return true;
                }
                return false;
            });

            // If no exact match, try contains matching (more dangerous)
            if (!currentSong) {
                const currentNorm = currentSongName.normalize('NFC').toLowerCase();

                currentSong = thematicProfiles.profiles.find(p => {
                    const pNameNorm = p.songName.normalize('NFC').toLowerCase();
                    const pTitleNorm = (p.songTitle || '').normalize('NFC').toLowerCase();

                    // Strategy 3: songTitle contains current (must be significant overlap)
                    if (currentNorm.length >= 3 && pTitleNorm.includes(currentNorm)) {
                        console.log('[ThematicRadar] Match strategy 3 (songTitle contains):', p.songName);
                        return true;
                    }
                    // Strategy 4: songName contains current
                    if (currentNorm.length >= 5 && pNameNorm.includes(currentNorm)) {
                        console.log('[ThematicRadar] Match strategy 4 (songName contains):', p.songName);
                        return true;
                    }
                    return false;
                });
            }

            // If still not found, try backend format conversion (remove tones, lowercase, hyphenate)
            if (!currentSong) {
                const backendFormat = currentSongName
                    .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Remove diacritics
                    .toLowerCase()
                    .replace(/[^a-z0-9\s-]/g, '') // Remove special chars
                    .trim()
                    .replace(/\s+/g, '-'); // Spaces to hyphens

                console.log('[ThematicRadar] Trying backend format:', backendFormat);

                currentSong = thematicProfiles.profiles.find(p => {
                    const match = p.songName.toLowerCase().includes(backendFormat) ||
                                 backendFormat.includes(p.songName.toLowerCase());
                    if (match) {
                        console.log('[ThematicRadar] Match strategy 6 (backend format):', p.songName);
                    }
                    return match;
                });
            }

            // Last resort: first song
            if (!currentSong) {
                console.warn('[ThematicRadar] Could not match song, using first:', currentSongName);
                currentSong = thematicProfiles.profiles[0];
            }

            console.log('[ThematicRadar] Final matched song:', currentSong.songName, '/', currentSong.songTitle);

            // Populate song selector
            populateSongSelector();

            // Render initial chart
            renderRadar();

            console.log('[ThematicRadar] Loaded data, current song:', currentSong.songTitle);
        } catch (error) {
            console.error('[ThematicRadar] Error loading data:', error);
        }
    }

    // Helper: Get 7-axis data (including "other")
    function get7AxisData(profile) {
        return [
            ...profile.radarData,  // 6 categories
            parseFloat(profile.themePercentages.other)  // Add "other"
        ];
    }

    // Helper: Get current data based on includeFunc toggle
    function getRadarData(profile) {
        return includeFunctionalWords ? get7AxisData(profile) : profile.radarData;
    }

    // Toggle function
    window.toggleFunctionalWords = function() {
        const checkbox = document.getElementById('includeFunctionalWords');
        includeFunctionalWords = checkbox.checked;

        // Update UI
        document.getElementById('axisCountLabel').textContent = includeFunctionalWords ? '7' : '6';
        document.getElementById('otherCategoryInfo').style.display = includeFunctionalWords ? 'block' : 'none';

        // Re-render chart
        renderRadar();

        console.log(`[ThematicRadar] Switched to ${includeFunctionalWords ? '7-axis' : '6-axis'} mode`);
    };

    function populateSongSelector() {
        const selector = document.getElementById('songSelector');
        if (!selector) return;

        // Sort songs by title
        const sorted = [...thematicProfiles.profiles].sort((a, b) => a.songTitle.localeCompare(b.songTitle));

        selector.innerHTML = '<option value="">-- Choose a song --</option>' +
            sorted.map(p => `<option value="${p.songName}">${p.songTitle}</option>`).join('');
    }

    window.setRadarMode = function(mode) {
        currentMode = mode;

        // Update button styles
        document.querySelectorAll('.radar-mode-btn').forEach(btn => {
            if (btn.dataset.mode === mode) {
                btn.style.border = '2px solid #3498db';
                btn.style.background = '#e3f2fd';
                btn.style.color = '#3498db';
                btn.classList.add('active');
            } else {
                btn.style.border = '1px solid #ddd';
                btn.style.background = 'white';
                btn.style.color = '#666';
                btn.classList.remove('active');
            }
        });

        // Show/hide multi-song controls
        const multiControls = document.getElementById('multiSongControls');
        if (multiControls) {
            multiControls.style.display = mode === 'multi-song' ? 'block' : 'none';
        }

        renderRadar();
    };

    window.addSongToRadar = function() {
        if (selectedSongs.length >= 10) {
            alert('Maximum 10 songs can be compared at once');
            return;
        }

        const selector = document.getElementById('songSelector');
        const songName = selector.value;
        if (!songName) return;

        const profile = thematicProfiles.profiles.find(p => p.songName === songName);
        if (!profile) return;

        // Check if already added
        if (selectedSongs.find(s => s.songName === songName)) {
            alert('Song already added');
            return;
        }

        selectedSongs.push(profile);
        updateSelectedSongsUI();
        renderRadar();

        // Reset selector
        selector.value = '';
    };

    window.addSimilarSongs = function() {
        if (!currentSong || !currentSong.similarSongs) return;

        // Add top 5 most similar songs
        const toAdd = currentSong.similarSongs.slice(0, 5);
        toAdd.forEach(similar => {
            const profile = thematicProfiles.profiles.find(p => p.songName === similar.songName);
            if (profile && !selectedSongs.find(s => s.songName === profile.songName) && selectedSongs.length < 10) {
                selectedSongs.push(profile);
            }
        });

        updateSelectedSongsUI();
        renderRadar();
    };

    window.addDifferentSongs = function() {
        if (!currentSong || !currentSong.similarSongs) return;

        // Add 5 least similar songs (lowest similarity scores)
        const sorted = [...currentSong.similarSongs].sort((a, b) => parseFloat(a.similarity) - parseFloat(b.similarity));
        const toAdd = sorted.slice(0, 5);

        toAdd.forEach(different => {
            const profile = thematicProfiles.profiles.find(p => p.songName === different.songName);
            if (profile && !selectedSongs.find(s => s.songName === profile.songName) && selectedSongs.length < 10) {
                selectedSongs.push(profile);
            }
        });

        updateSelectedSongsUI();
        renderRadar();
    };

    window.clearAllSongs = function() {
        selectedSongs = [];
        updateSelectedSongsUI();
        renderRadar();
    };

    window.removeSongFromRadar = function(songName) {
        selectedSongs = selectedSongs.filter(s => s.songName !== songName);
        updateSelectedSongsUI();
        renderRadar();
    };

    function updateSelectedSongsUI() {
        const container = document.getElementById('selectedSongsChips');
        if (!container) return;

        if (selectedSongs.length === 0) {
            container.innerHTML = '<div style="color: #999; font-size: 12px;">No songs selected</div>';
            return;
        }

        container.innerHTML = selectedSongs.map((song, idx) => `
            <div style="background: ${chartColors[idx].border}; color: white; padding: 5px 10px; border-radius: 15px; font-size: 12px; display: flex; align-items: center; gap: 6px;">
                <span>${song.songTitle}</span>
                <span onclick="removeSongFromRadar('${song.songName}')" style="cursor: pointer; font-weight: bold; font-size: 14px;">√ó</span>
            </div>
        `).join('');
    }

    // Cache for word lists (to avoid re-fetching on every hover)
    let currentSongWords = null;

    async function renderRadar() {
        const ctx = document.getElementById('thematicRadarChart');
        if (!ctx) return;

        if (radarChart) radarChart.destroy();

        // Load current song's words for tooltips
        try {
            const response = await fetch(`/api/lyrics/${encodeURIComponent(currentSong.songName)}`);
            const lyricsData = await response.json();
            currentSongWords = categorizeAllWords(lyricsData);
        } catch (err) {
            console.error('[ThematicRadar] Error loading words for tooltips:', err);
            currentSongWords = null;
        }

        let datasets = [];
        let insights = '';

        if (currentMode === 'current-vs-avg') {
            // Current song vs collection average
            const collectionAvg = [
                parseFloat(vocabularyMetrics.semanticCategories.nature.percentage),
                parseFloat(vocabularyMetrics.semanticCategories.family.percentage),
                parseFloat(vocabularyMetrics.semanticCategories.emotion.percentage),
                parseFloat(vocabularyMetrics.semanticCategories.work.percentage),
                parseFloat(vocabularyMetrics.semanticCategories.time.percentage),
                parseFloat(vocabularyMetrics.semanticCategories.place.percentage)
            ];

            datasets = [
                {
                    label: 'Collection Average',
                    data: collectionAvg,
                    backgroundColor: 'rgba(149, 165, 166, 0.2)',
                    borderColor: '#95a5a6',
                    borderWidth: 2,
                    pointBackgroundColor: '#95a5a6',
                    pointRadius: 4
                },
                {
                    label: currentSong.songTitle,
                    data: getRadarData(currentSong),
                    backgroundColor: 'rgba(52, 152, 219, 0.3)',
                    borderColor: '#3498db',
                    borderWidth: 3,
                    pointBackgroundColor: '#3498db',
                    pointRadius: 5
                }
            ];

            insights = await generateCurrentSongInsights(currentSong, collectionAvg);

        } else if (currentMode === 'multi-song') {
            // Multi-song overlay
            if (selectedSongs.length === 0) {
                datasets = [{
                    label: currentSong.songTitle,
                    data: getRadarData(currentSong),
                    backgroundColor: chartColors[0].bg,
                    borderColor: chartColors[0].border,
                    borderWidth: 2,
                    pointBackgroundColor: chartColors[0].border,
                    pointRadius: 4
                }];
                insights = `<p>Select songs above to overlay their thematic profiles.</p>`;
            } else {
                datasets = selectedSongs.map((song, idx) => ({
                    label: song.songTitle,
                    data: getRadarData(song),
                    backgroundColor: chartColors[idx].bg,
                    borderColor: chartColors[idx].border,
                    borderWidth: 2,
                    pointBackgroundColor: chartColors[idx].border,
                    pointRadius: 4
                }));

                insights = await generateMultiSongInsights(selectedSongs);
            }

        } else if (currentMode === 'regional') {
            // Regional averages
            const regional = thematicProfiles.collectionStats.byRegion;
            datasets = Object.entries(regional).map(([region, data]) => ({
                label: region,
                data: data.radarData,
                backgroundColor: getRegionalColor(region).bg,
                borderColor: getRegionalColor(region).border,
                borderWidth: 2,
                pointBackgroundColor: getRegionalColor(region).border,
                pointRadius: 4
            }));

            insights = generateRegionalInsights(regional);

        } else if (currentMode === 'genre') {
            // Genre averages
            const genres = thematicProfiles.collectionStats.byGenre;
            datasets = Object.entries(genres).map(([genre, data]) => ({
                label: genre,
                data: data.radarData,
                backgroundColor: getGenreColor(genre).bg,
                borderColor: getGenreColor(genre).border,
                borderWidth: 2,
                pointBackgroundColor: getGenreColor(genre).border,
                pointRadius: 4
            }));

            insights = generateGenreInsights(genres);
        }

        // Dynamic labels based on mode
        const labels = includeFunctionalWords
            ? ['üåø Nature', 'üë®‚Äçüë©‚Äçüëß Family', 'üíó Emotion', '‚öíÔ∏è Work', '‚è∞ Time', 'üìç Place', 'üí¨ Other']
            : ['üåø Nature', 'üë®‚Äçüë©‚Äçüëß Family', 'üíó Emotion', '‚öíÔ∏è Work', '‚è∞ Time', 'üìç Place'];

        // Dynamic scale max (7-axis needs higher max for "other")
        const scaleMax = includeFunctionalWords ? 70 : 15;
        const stepSize = includeFunctionalWords ? 10 : 3;

        radarChart = new Chart(ctx, {
            type: 'radar',
            data: {
                labels: labels,
                datasets: datasets
            },
            options: {
                responsive: true,
                maintainAspectRatio: true,
                scales: {
                    r: {
                        min: 0,
                        max: scaleMax,
                        ticks: {
                            stepSize: stepSize,
                            callback: (value) => value + '%',
                            font: { size: 11 }
                        },
                        pointLabels: {
                            font: { size: 14, weight: 'bold' }
                        },
                        grid: {
                            color: 'rgba(0, 0, 0, 0.1)'
                        }
                    }
                },
                plugins: {
                    legend: {
                        position: 'top',
                        labels: {
                            font: { size: 13, weight: '600' },
                            padding: 12,
                            usePointStyle: true
                        }
                    },
                    tooltip: {
                        backgroundColor: 'rgba(0, 0, 0, 0.7)',
                        padding: 8,
                        titleFont: { size: 12, weight: 'bold' },
                        bodyFont: { size: 10 },
                        bodySpacing: 4,
                        displayColors: false,
                        caretSize: 6,
                        caretPadding: 8,
                        cornerRadius: 4,
                        xAlign: 'right',   // Push tooltip to the right
                        yAlign: 'top',     // Push tooltip to top
                        callbacks: {
                            title: (context) => {
                                const labelIndex = context[0].dataIndex;
                                const themeNames = ['Nature', 'Family', 'Emotion', 'Work', 'Time', 'Place', 'Other'];
                                return themeNames[labelIndex] || 'Theme';
                            },
                            label: (context) => {
                                return context.dataset.label + ': ' + context.parsed.r.toFixed(2) + '%';
                            },
                            afterLabel: (context) => {
                                // Show word list only for current song dataset
                                if (!currentSongWords || context.dataset.label !== currentSong.songTitle) {
                                    return null;
                                }

                                const labelIndex = context.dataIndex;
                                const themeKeys = ['nature', 'family', 'emotion', 'work', 'time', 'place', 'other'];
                                const themeKey = themeKeys[labelIndex];

                                const words = currentSongWords[themeKey] || [];
                                if (words.length === 0) return null;

                                // Limit to first 8 words + count (reduced from 20)
                                const displayWords = words.slice(0, 8);
                                const moreCount = words.length - displayWords.length;

                                const lines = [
                                    '', // Blank line for spacing
                                    `${words.length} words:`,
                                    displayWords.join(', ')
                                ];

                                if (moreCount > 0) {
                                    lines.push(`+${moreCount} more`);
                                }

                                return lines;
                            }
                        }
                    }
                }
            }
        });

        document.getElementById('insightsContent').innerHTML = insights;
        console.log(`[ThematicRadar] Rendered in ${currentMode} mode`);
    }

    async function generateCurrentSongInsights(song, avgData) {
        const themes = ['nature', 'family', 'emotion', 'work', 'time', 'place'];
        const diffs = themes.map((theme, i) => ({
            theme,
            song: song.radarData[i],
            avg: avgData[i],
            diff: song.radarData[i] - avgData[i]
        }));

        const maxDiff = diffs.reduce((max, d) => Math.abs(d.diff) > Math.abs(max.diff) ? d : max);
        const dominant = diffs.reduce((max, d) => d.song > max.song ? d : max);

        const getIcon = (t) => ({ nature: 'üåø', family: 'üë®‚Äçüë©‚Äçüëß', emotion: 'üíó', work: '‚öíÔ∏è', time: '‚è∞', place: 'üìç', other: 'üí¨' }[t]);

        // Load lyrics data to get actual words
        let wordsByCategory = null;
        let loadError = null;
        try {
            console.log(`[ThematicRadar] Loading lyrics for: ${song.songName}`);
            const response = await fetch(`/api/lyrics/${encodeURIComponent(song.songName)}`);
            if (!response.ok) {
                throw new Error(`HTTP ${response.status}: ${response.statusText}`);
            }
            const lyricsData = await response.json();
            wordsByCategory = categorizeAllWords(lyricsData);
            console.log(`[ThematicRadar] Categorized words:`, Object.keys(wordsByCategory).map(k => `${k}:${wordsByCategory[k].length}`).join(', '));
        } catch (err) {
            console.error('[ThematicRadar] Error loading lyrics:', err);
            loadError = err.message;
        }

        // Build word list HTML
        let wordListHTML = '';
        if (wordsByCategory) {
            const categoriesToShow = includeFunctionalWords
                ? ['nature', 'family', 'emotion', 'work', 'time', 'place', 'other']
                : ['nature', 'family', 'emotion', 'work', 'time', 'place'];

            wordListHTML = categoriesToShow.map(theme => {
                const words = wordsByCategory[theme] || [];
                if (words.length === 0) return '';

                const percentage = song.themePercentages[theme];
                return `
                    <div style="margin-bottom: 12px; padding: 10px; background: white; border-radius: 6px; border-left: 3px solid ${categoryColors[theme] || '#999'};">
                        <div style="font-weight: 600; color: ${categoryColors[theme] || '#999'}; margin-bottom: 5px; font-size: 13px;">
                            ${getIcon(theme)} ${theme.toUpperCase()} (${percentage}%)
                        </div>
                        <div style="font-size: 11px; color: #666; line-height: 1.5;">
                            ${words.join(', ')}
                        </div>
                        <div style="font-size: 10px; color: #999; margin-top: 4px;">
                            ${words.length} word${words.length > 1 ? 's' : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        return `
            <div style="background: ${maxDiff.diff > 0 ? '#e8f5e9' : '#ffebee'}; padding: 12px; border-radius: 6px; margin-bottom: 10px;">
                <div style="font-weight: 600; color: ${maxDiff.diff > 0 ? '#27ae60' : '#e74c3c'}; margin-bottom: 5px;">
                    ${getIcon(maxDiff.theme)} Most ${maxDiff.diff > 0 ? 'Over' : 'Under'}-Emphasized
                </div>
                <div style="font-size: 13px; color: #666;">
                    <strong>${maxDiff.theme.toUpperCase()}:</strong> ${maxDiff.song.toFixed(2)}%
                    <br>
                    (avg: ${maxDiff.avg.toFixed(2)}%, ${maxDiff.diff > 0 ? '+' : ''}${maxDiff.diff.toFixed(2)}%)
                </div>
            </div>

            <div style="background: #fff3e0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                <div style="font-weight: 600; color: #f39c12; margin-bottom: 5px;">
                    ${getIcon(dominant.theme)} Dominant Theme
                </div>
                <div style="font-size: 13px; color: #666;">
                    <strong>${dominant.theme.toUpperCase()}:</strong> ${dominant.song.toFixed(2)}%
                </div>
            </div>

            <div style="font-size: 12px; color: #999; padding-bottom: 12px; margin-bottom: 12px; border-bottom: 1px solid #e0e0e0;">
                <strong>Total Words:</strong> ${song.totalWords}<br>
                <strong>Phrases:</strong> ${song.totalPhrases}<br>
                <strong>Region:</strong> ${song.region}<br>
                <strong>Genre:</strong> ${song.genre}
            </div>

            <div style="max-height: 400px; overflow-y: auto; border-top: 2px solid #3498db; padding-top: 12px; margin-top: 12px;">
                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 10px; font-size: 14px;">
                    Words by Category:
                    ${wordsByCategory ? '(' + Object.values(wordsByCategory).reduce((sum, arr) => sum + arr.length, 0) + ' total words)' : ''}
                </div>
                ${loadError ?
                    `<div style="color: #e74c3c; font-size: 12px; padding: 10px; background: #ffebee; border-radius: 6px;">
                        <strong>Error loading lyrics:</strong><br>${loadError}
                    </div>`
                    : wordsByCategory && wordListHTML ?
                        wordListHTML
                    : `<div style="color: #999; font-size: 12px; padding: 10px; background: #f0f0f0; border-radius: 6px;">
                        <strong>Debug:</strong><br>
                        wordsByCategory: ${wordsByCategory ? 'loaded' : 'null'}<br>
                        wordListHTML length: ${wordListHTML ? wordListHTML.length : 0}<br>
                        Song: ${song.songName}
                    </div>`
                }
            </div>
        `;
    }

    async function generateMultiSongInsights(songs) {
        if (songs.length === 0) return '<p>Select songs to compare.</p>';

        const getIcon = (t) => ({ nature: 'üåø', family: 'üë®‚Äçüë©‚Äçüëß', emotion: 'üíó', work: '‚öíÔ∏è', time: '‚è∞', place: 'üìç', other: 'üí¨' }[t]);

        // Load lyrics data for each song and categorize words
        const songWordsData = await Promise.all(songs.map(async (song, idx) => {
            try {
                const response = await fetch(`/api/lyrics/${encodeURIComponent(song.songName)}`);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                const lyricsData = await response.json();
                const wordsByCategory = categorizeAllWords(lyricsData);
                return { song, wordsByCategory, color: chartColors[idx].border, index: idx };
            } catch (err) {
                console.error(`[ThematicRadar] Error loading lyrics for ${song.songTitle}:`, err);
                return { song, wordsByCategory: null, color: chartColors[idx].border, index: idx };
            }
        }));

        // Find most similar pair
        let mostSimilar = { sim: 0, pair: [0, 1] };
        for (let i = 0; i < songs.length; i++) {
            for (let j = i + 1; j < songs.length; j++) {
                const sim = calculateSimilarity(songs[i].radarData, songs[j].radarData);
                if (sim > mostSimilar.sim) {
                    mostSimilar = { sim, pair: [i, j] };
                }
            }
        }

        // Build insight cards for each song
        const insightCards = songWordsData.map(({ song, wordsByCategory, color, index }) => {
            if (!wordsByCategory) {
                return `
                    <div style="background: white; padding: 12px; border-radius: 8px; border-left: 4px solid ${color}; height: 100%;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 10px;">
                            <div style="width: 12px; height: 12px; background: ${color}; border-radius: 2px;"></div>
                            <div style="font-weight: 600; color: #2c3e50; font-size: 13px;">${song.songTitle}</div>
                        </div>
                        <div style="color: #e74c3c; font-size: 11px; padding: 8px; background: #ffebee; border-radius: 4px;">
                            Error loading lyrics data
                        </div>
                    </div>
                `;
            }

            const categoriesToShow = includeFunctionalWords
                ? ['nature', 'family', 'emotion', 'work', 'time', 'place', 'other']
                : ['nature', 'family', 'emotion', 'work', 'time', 'place'];

            const categoryHTML = categoriesToShow.map(theme => {
                const words = wordsByCategory[theme] || [];
                if (words.length === 0) return '';

                const percentage = song.themePercentages[theme];
                return `
                    <div style="margin-bottom: 6px; padding: 6px; background: #f9f9f9; border-radius: 4px; border-left: 2px solid ${categoryColors[theme] || '#999'};">
                        <div style="font-weight: 600; color: ${categoryColors[theme] || '#999'}; margin-bottom: 3px; font-size: 10px;">
                            ${getIcon(theme)} ${theme.toUpperCase()} (${percentage}%)
                        </div>
                        <div style="font-size: 9px; color: #666; line-height: 1.3;">
                            ${words.join(', ')}
                        </div>
                        <div style="font-size: 8px; color: #999; margin-top: 2px;">
                            ${words.length} syllable${words.length > 1 ? 's' : ''}
                        </div>
                    </div>
                `;
            }).join('');

            return `
                <div style="background: white; padding: 12px; border-radius: 8px; border-left: 4px solid ${color}; box-shadow: 0 2px 4px rgba(0,0,0,0.1); height: 100%; display: flex; flex-direction: column;">
                    <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 8px;">
                        <div style="width: 12px; height: 12px; background: ${color}; border-radius: 2px;"></div>
                        <div style="font-weight: 600; color: #2c3e50; font-size: 13px;">${song.songTitle}</div>
                    </div>
                    <div style="font-size: 9px; color: #999; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #eee;">
                        <strong>Total:</strong> ${song.totalWords} words | <strong>Phrases:</strong> ${song.totalPhrases}
                    </div>
                    <div style="flex: 1; overflow-y: auto; max-height: 400px;">
                        ${categoryHTML || '<div style="color: #999; font-size: 10px;">No categorized words</div>'}
                    </div>
                </div>
            `;
        }).join('');

        // Summary section
        const themeCounts = {};
        songs.forEach(s => {
            themeCounts[s.dominantTheme] = (themeCounts[s.dominantTheme] || 0) + 1;
        });

        return `
            <div style="margin-bottom: 15px; padding: 12px; background: #f0f7ff; border-radius: 8px;">
                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px; font-size: 14px;">
                    Comparing ${songs.length} Songs
                </div>
                ${songs.map((s, i) => `
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                        <div style="width: 12px; height: 12px; background: ${chartColors[i].border}; border-radius: 2px;"></div>
                        <div style="font-size: 12px; color: #666;">${s.songTitle}</div>
                    </div>
                `).join('')}
            </div>

            ${mostSimilar.sim > 0 ? `
                <div style="background: #e8f5e9; padding: 12px; border-radius: 6px; margin-bottom: 12px;">
                    <div style="font-weight: 600; color: #27ae60; margin-bottom: 5px; font-size: 13px;">Most Similar Pair</div>
                    <div style="font-size: 11px; color: #666;">
                        ${songs[mostSimilar.pair[0]].songTitle}<br>
                        ${songs[mostSimilar.pair[1]].songTitle}<br>
                        <strong>${mostSimilar.sim.toFixed(1)}% similarity</strong>
                    </div>
                </div>
            ` : ''}

            <div style="background: #fff3e0; padding: 12px; border-radius: 6px; margin-bottom: 15px;">
                <div style="font-weight: 600; color: #f39c12; margin-bottom: 5px; font-size: 13px;">Dominant Themes</div>
                ${Object.entries(themeCounts).map(([theme, count]) => `
                    <div style="font-size: 11px; color: #666;">
                        ${theme}: ${count} song${count > 1 ? 's' : ''}
                    </div>
                `).join('')}
            </div>

            <div style="border-top: 2px solid #3498db; padding-top: 12px; margin-top: 12px;">
                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 12px; font-size: 14px;">
                    Word Details by Song
                </div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 12px;">
                    ${insightCards}
                </div>
            </div>
        `;
    }

    function generateRegionalInsights(regional) {
        const regions = Object.keys(regional);
        return `
            <div style="margin-bottom: 15px;">
                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Regional Patterns</div>
                ${regions.map(region => {
                    const data = regional[region];
                    const dominant = ['nature', 'family', 'emotion', 'work', 'time', 'place']
                        .reduce((max, theme, i) => data.radarData[i] > max.val ? { theme, val: data.radarData[i] } : max, { theme: 'none', val: 0 });

                    return `
                        <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px; border-left: 3px solid ${getRegionalColor(region).border};">
                            <div style="font-weight: 600; color: ${getRegionalColor(region).border};">${region} (${data.songs.length} songs)</div>
                            <div style="font-size: 11px; color: #666;">Emphasizes: ${dominant.theme} (${dominant.val.toFixed(1)}%)</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }

    function generateGenreInsights(genres) {
        const genreList = Object.keys(genres);
        return `
            <div style="margin-bottom: 15px;">
                <div style="font-weight: 600; color: #2c3e50; margin-bottom: 8px;">Genre Patterns</div>
                ${genreList.map(genre => {
                    const data = genres[genre];
                    const dominant = ['nature', 'family', 'emotion', 'work', 'time', 'place']
                        .reduce((max, theme, i) => data.radarData[i] > max.val ? { theme, val: data.radarData[i] } : max, { theme: 'none', val: 0 });

                    return `
                        <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 6px; border-left: 3px solid ${getGenreColor(genre).border};">
                            <div style="font-weight: 600; color: ${getGenreColor(genre).border};">${genre} (${data.songs.length} songs)</div>
                            <div style="font-size: 11px; color: #666;">Emphasizes: ${dominant.theme} (${dominant.val.toFixed(1)}%)</div>
                        </div>
                    `;
                }).join('')}
            </div>
        `;
    }

    function calculateSimilarity(a, b) {
        const dot = a.reduce((sum, val, i) => sum + val * b[i], 0);
        const magA = Math.sqrt(a.reduce((sum, val) => sum + val * val, 0));
        const magB = Math.sqrt(b.reduce((sum, val) => sum + val * val, 0));
        return magA && magB ? (dot / (magA * magB)) * 100 : 0;
    }

    function getRegionalColor(region) {
        const colors = {
            'Northern': { bg: 'rgba(52, 152, 219, 0.2)', border: '#3498db' },
            'Southern': { bg: 'rgba(231, 76, 60, 0.2)', border: '#e74c3c' },
            'Central': { bg: 'rgba(243, 156, 18, 0.2)', border: '#f39c12' },
            'Highland': { bg: 'rgba(39, 174, 96, 0.2)', border: '#27ae60' }
        };
        return colors[region] || chartColors[0];
    }

    function getGenreColor(genre) {
        const colors = {
            'H√≤': { bg: 'rgba(52, 152, 219, 0.2)', border: '#3498db' },
            'L√Ω': { bg: 'rgba(39, 174, 96, 0.2)', border: '#27ae60' },
            'Ru': { bg: 'rgba(231, 76, 60, 0.2)', border: '#e74c3c' },
            'Quan h·ªç': { bg: 'rgba(155, 89, 182, 0.2)', border: '#9b59b6' },
            'Folk': { bg: 'rgba(149, 165, 166, 0.2)', border: '#95a5a6' }
        };
        return colors[genre] || chartColors[0];
    }

    window.toggleThematicRadar = function() {
        const content = document.getElementById('thematicRadarContent');
        const toggle = document.getElementById('thematicRadarCollapse');

        if (content.classList.contains('collapsed')) {
            content.classList.remove('collapsed');
            content.style.display = 'block';
            toggle.textContent = '‚ñº';
            console.log('[ThematicRadar] Expanded');
        } else {
            content.classList.add('collapsed');
            content.style.display = 'none';
            toggle.textContent = '‚ñ∂';
            console.log('[ThematicRadar] Collapsed');
        }
    };

    window.refreshThematicRadar = async function() {
        console.log('[ThematicRadar] Refreshing for new song...');
        await loadData();
    };

    // Listen for song changes from library
    window.addEventListener('songChanged', async (event) => {
        console.log('[ThematicRadar] Detected song change:', event.detail);

        // Update current song using same matching logic as loadData()
        const newSongName = event.detail.songName || event.detail;
        const newSongNorm = newSongName.normalize('NFC').toLowerCase();

        currentSong = thematicProfiles.profiles.find(p => {
            const pNameNorm = p.songName.normalize('NFC').toLowerCase();
            const pTitleNorm = (p.songTitle || '').normalize('NFC').toLowerCase();

            // Exact match only (no substring matching)
            return pTitleNorm === newSongNorm || pNameNorm === newSongNorm;
        });

        if (!currentSong) {
            console.warn('[ThematicRadar] Could not find song:', newSongName);
            return; // Don't update if song not found
        }

        console.log('[ThematicRadar] Switched to song:', currentSong.songTitle);

        // Re-render with new song
        await renderRadar();
    });

    // Listen for URL changes (browser back/forward, direct navigation)
    window.addEventListener('popstate', async () => {
        console.log('[ThematicRadar] URL changed, reloading data');
        await loadData();
    });

    document.addEventListener('DOMContentLoaded', () => {
        loadData();
        console.log('[ThematicRadar] Component initialized');
    });

})();
</script>

<style>
#thematicRadarContent.collapsed {
    display: none !important;
}

.radar-mode-btn.active {
    border: 2px solid #3498db !important;
    background: #e3f2fd !important;
    color: #3498db !important;
}

/* Force tooltip to top-right corner */
#thematicRadarChart {
    position: relative;
}

/* Override Chart.js tooltip positioning */
.chartjs-tooltip {
    position: absolute !important;
    top: 10px !important;
    right: 10px !important;
    left: auto !important;
    transform: none !important;
    max-width: 300px !important;
}
</style>
